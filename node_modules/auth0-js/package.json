{
  "name": "auth0-js",
  "version": "6.8.0",
  "description": "Auth0 headless browser sdk",
  "main": "index.js",
  "keywords": [
    "auth0",
    "auth",
    "openid",
    "authentication",
    "jwt",
    "browser"
  ],
  "scripts": {
    "test": "grunt integration",
    "example": "grunt example",
    "phantom": "grunt phantom",
    "build": "grunt build",
    "dev": "grunt dev"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/auth0/auth0.js"
  },
  "author": {
    "name": "Jose F. Romaniello",
    "email": "jfromaniello@gmail.com",
    "url": "http://joseoncode.com"
  },
  "license": "MIT",
  "dependencies": {
    "Base64": "~0.1.3",
    "debug": "~1.0.4",
    "json-fallback": "0.0.1",
    "jsonp": "~0.0.4",
    "qs": "git+https://github.com/jfromaniello/node-querystring.git#fix_ie7_bug_with_arrays",
    "reqwest": "^1.1.4",
    "trim": "~0.0.1",
    "winchan": "^0.1.1",
    "xtend": "~2.1.1"
  },
  "devDependencies": {
    "browserify": "~2.35.0",
    "browserstack-cli": "0.3.1",
    "bump-version": "^0.5.0",
    "expect.js": "~0.2.0",
    "grunt": "~0.4.5",
    "grunt-aws-s3": "~0.9.3",
    "grunt-browserify": "~1.2.8",
    "grunt-cli": "~0.1.9",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-contrib-connect": "~0.5.0",
    "grunt-contrib-copy": "~0.4.1",
    "grunt-contrib-uglify": "~0.2.4",
    "grunt-contrib-watch": "~0.2.0",
    "grunt-exec": "~0.4.2",
    "grunt-fastly": "~0.1.3",
    "grunt-http": "^1.6.0",
    "mocha": "1.20.1",
    "phantomjs": "^1.9.2-6",
    "rimraf": "~2.2.2",
    "sinon": "1.16.1",
    "uglify-js": "~2.4.0",
    "unreleased": "^0.1.0",
    "zuul": "3.6.0",
    "zuul-ngrok": "3.0.0"
  },
  "readme": "![](https://cdn.auth0.com/resources/oss-source-large-2x.png)\n\n# Auth0.js\n[![NPM version][npm-image]][npm-url]\n[![Build status][strider-image]][strider-url]\n[![Test coverage][coveralls-image]][coveralls-url]\n[![Dependency Status][david-image]][david-url]\n[![License][license-image]][license-url]\n[![Downloads][downloads-image]][downloads-url]\n\n[Auth0](http://auth0.com) is an authentication broker that supports social identity providers as well as enterprise identity providers such as Active Directory, LDAP, Office365, Google Apps, Salesforce.\n\nAuth0.js is a client-side library for [Auth0](http://auth0.com). It allows you to trigger the authentication process and parse the [JWT](http://openid.net/specs/draft-jones-json-web-token-07.html) (JSON web token) with just the Auth0 `clientID`. Once you have the JWT you can use it to authenticate requests to your http API and validate the JWT in your server-side logic with the `clientSecret`.\n\n## Example\n\nThe example directory has a ready-to-go app. In order to run it you need [node](http://nodejs.org/) installed, download dependencies with `npm install`, then execute `npm run example` from the root of this project.\n\n## Usage\n\nTake `auth0.js` or `auth0.min.js` from the `/build` directory and import it to your page.\n\nIf you are using [browserify](http://browserify.org/) install with `npm i auth0-js --production --save`.\n\n> Note: The following examples use jQuery, but auth0.js is not tied to jQuery and any library can be used with it.\n\n### Initialize:\n\nConstruct a new instance of the Auth0 client as follows:\n\n```html\n<script src=\"//cdn.auth0.com/w2/auth0-6.js\"></script>\n<script type=\"text/javascript\">\n  var auth0 = new Auth0({\n    domain:       'mine.auth0.com',\n    clientID:     'dsa7d77dsa7d7',\n    callbackURL:  'http://my-app.com/callback',\n    callbackOnLocationHash: true\n  });\n\n  //...\n</script>\n```\n\n### Login:\n\nThis method can be called as indifferently as `signin` or `login`.\nTriggers the login on any of your active identity provider as follows:\n\n```js\n  //trigger login with google\n  $('.login-google').click(function () {\n    auth0.login({\n      connection: 'google-oauth2'\n    });\n  });\n\n  //trigger login with github\n  $('.login-github').click(function () {\n    auth0.login({\n      connection: 'github'\n    });\n  });\n\n  //trigger login with an enterprise connection\n  $('.login-microsoft').click(function () {\n    auth0.login({\n      connection: 'contoso.com'\n    });\n  });\n\n  //trigger login with a db connection\n  $('.login-dbconn').click(function () {\n    auth0.login({\n      connection: 'db-conn',\n      username:   $('.username').val(),\n      password:   $('.password').val(),\n    });\n  });\n\n  //trigger login with a db connection and avoid the redirect (best experience for SPA)\n  $('.login-dbconn').click(function () {\n    auth0.login({\n      connection: 'db-conn',\n      username:   $('.username').val(),\n      password:   $('.password').val(),\n    },\n    function (err, profile, id_token, access_token) {\n      // store in cookies\n    });\n  });\n\n  //trigger login popup with google\n  $('.login-google-popup').click(function (e) {\n    e.preventDefault();\n    auth0.login({\n      connection: 'google-oauth2',\n      popup: true,\n      popupOptions: {\n        width: 450,\n        height: 800\n      }\n    }, function(err, profile, id_token, access_token, state) {\n      if (err) {\n        alert(\"something went wrong: \" + err.message);\n        return;\n      }\n      alert('hello ' + profile.name);\n    });\n  });\n```\n\nYou can also request scopes that are not were not configured for the connection.\n\n```js\n  //trigger login requesting additional scopes with google\n  $('.login-google').click(function () {\n    auth0.login({\n      connection: 'google-oauth2',\n      connection_scope: ['https://www.googleapis.com/auth/orkut', 'https://picasaweb.google.com/data/']\n    });\n  });\n\n  // alternatively a comma separated list also works\n  $('.login-google').click(function () {\n    auth0.login({\n      connection: 'google-oauth2',\n      connection_scope: 'https://www.googleapis.com/auth/orkut,https://picasaweb.google.com/data/'\n    });\n  });\n```\n\nTrigger the login with offline mode support to get the `refresh_token`\n\n```js\n$('.login-dbconn').click(function () {\n    auth0.login({\n      connection: 'db-conn',\n      username:   $('.username').val(),\n      password:   $('.password').val(),\n      scope: 'openid offline_access'\n    },\n    function (err, profile, id_token, access_token, state, refresh_token) {\n      // store in cookies\n      // refresh_token is sent because offline_access is set as a scope\n    });\n  });\n```\n\n### Passwordless authentication\n\nPasswordless authentication allows users to log in by receiving a one-time password via email or text message.\n\n#### With Email\n\nOnce you have configured a passwordless `email` connection, you can request a link or a code to be sent via email that will allow the receiver to sign in to your application.\n\n\n##### Link\n\n```js\n$('.request-email-link').click(function (ev) {\n  ev.preventDefault();\n\n  auth0.requestMagicLink({\n    email: $('.email-input').val()\n  }, function (err) {\n    if (err) {\n      alert(err.error_description);\n      return;\n    }\n    // the request was successful and you should receive\n    // an email with the link at the specified address\n  });\n});\n```\n\n##### Code\n\n```js\n$('.request-email-code').click(function (ev) {\n  ev.preventDefault();\n\n  auth0.requestEmailCode({\n    email: $('.email-input').val()\n  }, function (err) {\n    if (err) {\n      alert(err.error_description);\n      return;\n    }\n    // the request was successful and you should receive\n    // an email with the code at the specified address\n  });\n});\n```\n\nOnce you receive the code you can call `verifyEmailCode` to authenticate the user using an `email` and a `code` and obtain the user's information such as its profile.\n\n```js\nauth0.verifyEmailCode({\n  email: $('.email-input').val(),\n  code: $('.email-code-input').val()\n}, function (err, profile, id_token, access_token, state, refresh_token) {\n  if (err) {\n    alert(\"something went wrong: \" + err.error_description);\n    return;\n  }\n  console.log(profile, id_token, access_token, state, refresh_token);\n});\n```\n\nIf you provide a `callbackURL` parameter when constructing the Auth0 instance, a redirect will be performed and the callback will only be invoked in the case of an error (notice it takes a single argument).\n\n```js\nauth0.verifyEmailCode(auth0.verifyEmailCode({\n  email: $('.email-input').val(),\n  code: $('.email-code-input').val()\n}, function (err) {\n  if (err) {\n    alert(\"something went wrong: \" + err.error_description);\n    return;\n  }\n});\n```\n\n#### With SMS\n\nFirst you must activate and configure your passwordless [Twilio](https://twilio.com) connection in our [dashboard](https://manage.auth0.com/#/connections/passwordless).\n\nAfter that you can request a passcode to be sent via SMS to a phone number. Ensure the phone number has the proper [full-length format](https://www.twilio.com/help/faq/phone-numbers/how-do-i-format-phone-numbers-to-work-internationally).\n\n\n```js\n$('.request-sms-code').click(function (ev) {\n  ev.preventDefault();\n\n  auth0.requestSMSCode({\n    phoneNumber: $('.phone-input').val()\n  }, function (err) {\n    if (err) {\n      alert(err.error_description);\n      return;\n    }\n    // the request was successful and you should receive\n    // a SMS with the code at the specified phone number\n  });\n});\n```\n\nOnce you receive the code you can call `verifySMSCode` to authenticate the user using an `phoneNumber` and a `code` and obtain the user's information such as its profile.\n\n```js\nauth0.verifySMSCode({\n  phoneNumber: $('.phone-input').val(),\n  code: $('.sms-code-input').val()\n}, function (err, profile, id_token, access_token, state, refresh_token) {\n  if (err) {\n    alert(\"something went wrong: \" + err.error_description);\n    return;\n  }\n  console.log(profile, id_token, access_token, state, refresh_token);\n});\n```\n\nIf you provide a `callbackURL` parameter when constructing the Auth0 instance, a redirect will be performed and the callback will only be invoked in the case of an error (notice it takes a single argument).\n\n```js\nauth0.verifySMSCode({\n  phoneNumber: $('.phone-input').val(),\n  code: $('.sms-code-input').val()\n}, function (err) {\n  if (err) {\n    alert(\"something went wrong: \" + err.error_description);\n    return;\n  }\n});\n```\n\n### Processing the Callback\n\nHow does control return back to your app after a login has been attempted?  This all depends on which login \"mode\" you choose to use (**Redirect** or **Popup**) and in some cases, which type of connection you're using.\n\n#### Redirect Mode\n\nThe default mode of the `login` method is Redirect Mode.  Here two separate \"redirect\" actions will occur when `login` is called.  First, the browser will navigate to a separate login page to collect the user's credentials.  Once the user successfully logs in, the browser will redirect the user *back* to your application via the `callbackURL`.\n\nFor example, let's say you've initialized your Auth0 client as shown in the [Initialize](#initialize) section above.  Then the following call to `login` using your `google-oauth2` social connection would result in a redirect to a Google login page and then a redirect back to `http://my-app.com/callback` if successful:\n\n```js\nauth0.login({\n  connection: 'google-oauth2'\n});\n```\n\n##### Single Page Apps\n\nIf you're building a SPA (Single Page Application) and using Redirect Mode, then your `callbackURL` should send the user back to the same page.  And because the `callbackOnLocationHash` initialization option was set to `true`, Auth0 will also append a hash to that URL that will contain an `access_token` and `id_token` (the JWT).  After control returns to your app, the full user profile can be retrieved via the `parseHash` and `getProfile` methods:\n\n```js\n$(function () {\n  var result = auth0.parseHash(window.location.hash);\n\n  //use result.id_token to call your rest api\n\n  if (result && result.id_token) {\n    auth0.getProfile(result.id_token, function (err, profile) {\n      alert('hello ' + profile.name);\n    });\n    // If offline_access was a requested scope\n    // You can grab the result.refresh_token here\n\n  } else if (result && result.error) {\n    alert('error: ' + result.error);\n  }\n});\n```\n\nIf the `scope` option used with the `login` method did not contain `openid profile`, then the profile will only contain `user_id`.  In that case just parse the hash to obtain the user ID:\n\n```js\n$(function () {\n    var result = auth0.parseHash(window.location.hash);\n    if (result && result.profile) {\n      alert('your user_id is: ' + result.profile.sub);\n      //use result.id_token to call your rest api\n    }\n  });\n});\n```\n\nIf there is no hash, `result` will be null.  If the hash contains the JWT, the `profile` field will be populated.\n\n##### Regular Web Apps\n\nIf you're building a regular web application (HTML pages rendered on the server), then `callbackURL` should point to a server-side endpoint that will process the successful login, primarily to set some sort of session cookie.  In this scenario you should make sure the `callbackOnLocationHash` option is `false` (or just not specified) when the Auth0 client is created:\n\n```js\nvar auth0 = new Auth0({\n  domain:       'mine.auth0.com',\n  clientID:     'dsa7d77dsa7d7',\n  callbackURL:  'http://my-app.com/callback'\n  // callbackOnLocationHash not set (defaults to false)\n});\n```\n\nOn successful login, Auth0 will redirect to your `callbackURL` with an appended authorization `code` query parameter.  Unlike the SPA scenario, this `code` value should get processed completely server-side.\n\n> Note: Server-side processing of the `code` looks something like this: Using whichever [Auth0 server-side SDK](https://auth0.com/docs/quickstart/webapp) necessary, the endpoint on the server should exchange the `code` for an `access_token` and `id_token` and optionally a full user profile.  It should then set some kind of local session cookie, which is what enables a user to be \"logged in\" to the website and usually contains data from the user profile.  It should finally redirect the user back to a meaningful page.\n\n#### Popup Mode\n\nBesides Redirect Mode, the `login` method also supports Popup Mode, which you enable by passing `popup: true` in the `options` argument.  In this mode the browser will *not* be redirected to a separate login page.  Instead Auth0 will display a popup window where the user enters their credentials.  The advantage of this approach is that the original page (and all of its state) remains intact, which can be important, especially for certain Single Page Apps.\n\n> **WARNING**: While Popup Mode does have the advantage of preserving page state, it has some issues. Often times users have popup blockers that prevent the login page from even displaying. There are also known issues with mobile browsers. For example, in recent versions of Chrome on iOS, the login popup does not get closed properly after login (see an example [here](https://github.com/auth0/lock/issues/71)). For these reasons, we encourage developers to favor Redirect Mode over Popup Mode, even with Single Page Apps.\n\nIn Popup Mode you also have no need to be redirected back to the application, since, once the user has logged in, the popup is simply closed.  Instead Auth0 uses the `login` method's `callback` argument to return control to your client-side application, for both failed and successful logins.  Along with the `err` argument, `callback` should also contain arguments `profile, id_token, access_token, state` (and optionally `refresh_token` if the `offline_access` scope has been requested):\n\n```js\nauth0.login({\n  popup: true,\n  connection: 'google-oauth2'\n},\nfunction(err, profile, id_token, access_token, state) {\n  if (err) {\n    // Handle the error!\n    return;\n  }\n\n  // Success!\n});\n```\n\n#### Database and Active Directory/LDAP connections\n\nThe behavior of Redirect and Popup Modes differs if you're using a [Database](https://auth0.com/docs/connections/database/mysql) or [Active Directory/LDAP](https://auth0.com/docs/connections/enterprise/active-directory) connection.  Those differences depend on two factors: whether SSO ([Single Sign-On](https://auth0.com/docs/sso/single-sign-on)) is enabled and whether or not credentials are being directly passed to the `login` method.\n\n##### SSO enabled\n\nBy default SSO is enabled (equivalent to passing the `sso: true` option to the `login` method).  This means that after a successful login, Auth0 will set a special cookie that [can be used](#sso) to automatically log a user onto additional websites that are registered as Auth0 apps.  When using either the Database or Active Directory/LDAP connections with SSO enabled, you can still choose to go with Redirect or Popup Mode.\n\nAs with other connection types, Redirect Mode will happen by default.  The browser will navigate to a login page that will prompt the user for their credentials and then, when login is complete, redirect back to the `callbackURL`.  However, one of the unique options you have with Database and Active Directory/LDAP connections is that the redirect to the login page can be bypassed if the `username` and `password` options are passed to the `login` method.  These values are typically collected via a *custom login form* in your app:\n\n```js\nauth0.login({\n  connection: 'db-conn',\n  username:   $('.username').val(),\n  password:   $('.password').val(),\n},\nfunction (err) {\n  // this only gets called if there was a login error\n});\n```\n\nIf the login is successful, the browser will then be redirected to `callbackURL`.  And as shown above a `callback` argument should also be provided to the `login` method that handles any authentication errors (without redirecting).\n\nFurthermore, sometimes you don't want a redirect to occur at all after a login.  This is often the case with Single Page Apps where a redirect will result in loss of important page state.  To handle all login results client-side, simply provide additional parameters to the `callback` argument JavaScript function:\n\n```js\nauth0.login({\n  connection: 'db-conn',\n  username:   $('.username').val(),\n  password:   $('.password').val(),\n},\nfunction(err, profile, id_token, access_token, state) {\n  if (err) {\n    // Handle the error!\n    return;\n  }\n\n  // Success!\n});\n```\n\n> Note: This `callback` approach is similar to what you'd do in the [Popup Mode](#popup-mode) scenario described earlier, except no popups (or redirects) occur since credentials are provided to the `login` method and success and failure is handled in the `callback` argument.\n\nYou can still do Popup Mode with SSO enabled with a Database or Active Directory/LDAP connection if you want to (but please see the **WARNING** in the [Popup Mode](#popup-mode) section above). This is similar to the Redirect Mode scenario where you don't have a custom login form, but want to use a popup window to collect the user's credentials, and also want control to return to the client-side code (vs. redirecting to `callbackURL`).  This behavior would occur if you simply specified the `popup: true` option:\n\n```js\nauth0.login({\n  connection: 'db-conn',\n  popup: true\n},\nfunction(err, profile, id_token, access_token, state) {\n  if (err) {\n    // Handle the error!\n    return;\n  }\n\n  // Success!\n});\n```\n\n##### SSO disabled\n\nIf you explicitly don't want SSO enabled in your application, you can pass the `sso: false` option to the `login` method.  The result is that when a login occurs, Auth0 performs a CORS POST request (or in IE8 or 9 a JSONP request) against a special \"resource owner\" endpoint (`/ro`), which allows users to authenticate by sending their username and password.  Also, no SSO cookie is set.\n\nThere are a couple important constraints at play when SSO is disabled:\n\n* Because the `/ro` endpoint requires credentials, the `username` and `password` options must be passed to the `login` method\n* It's not possible to use Popup Mode when SSO is disabled, even if you pass `popup: true`\n\nThis leaves you with a call to the `login` method that looks something like this:\n\n```js\nauth0.login({\n  connection: 'db-conn',\n  sso: false,\n  username:   $('.username').val(),\n  password:   $('.password').val()  \n},\nfunction(err) {\n  // this only gets called if there was a login error\n});\n```\n\nIf the login succeeds, Auth0 will redirect to your `callbackURL` and if it fails, control will be given to the `callback`.  \n\nAnd if you don't want that redirect to occur (i.e. you have a Single Page App), you can use a `callback` argument that takes the additional parameters (like what's shown in [Popup Mode](#popup-mode)), and control will go to your callback function with a failed or successful login.\n\n### Change Password (database connections):\n\n```js\n  $('.change_password').click(function () {\n    auth0.changePassword({\n      connection: 'db-conn',\n      username:   'foo@bar.com',\n      password:   'blabla' // new password\n    }, function (err, resp) {\n      console.log(err.message);\n    });\n  });\n```\n\n### Delegation Token Request\n\nA delegation token is a new token for a different service or app/API.\n\nIf you just want to get a new token for an addon that you've activated, you can do the following:\n\n```js\nvar options = {\n  id_token: \"your id token\", // The id_token you have now\n  api: 'firebase', // This defaults to the first active addon if any or you can specify this\n  \"scope\": \"openid profile\"\t\t    // default: openid\n};\n\nauth0.getDelegationToken(options, function (err, delegationResult) {\n\t// Call your API using delegationResult.id_token\n});\n```\n\nIf you want to get the token for another API or App:\n\n```js\nvar options = {\n  id_token: \"your id token\", // The id_token you have now\n  api: 'auth0' // This is default when calling another app that doesn't have an addon\n  targetClientId: 'The other client id'\n};\n\nauth0.getDelegationToken(options, function (err, delegationResult) {\n  // Call your API using delegationResult.id_token\n});\n```\n\n### Refresh token\n\nIf you want to refresh your existing (not expired) token, you can just do the following:\n\n```js\nauth0.renewIdToken(current_id_token, function (err, delegationResult) {\n  // Get here the new delegationResult.id_token\n});\n```\n\nIf you want to refresh your existing (expired) token, if you have the refresh_token, you can call the following:\n\n```js\nauth0.refreshToken(refresh_token, function (err, delegationResult) {\n  // Get here the new delegationResult.id_token\n});\n```\n\n### Validate User\n\nYou can validate a user of a specific connection with his username and password:\n\n```js\nauth0.validateUser({\n  connection:   'db-conn',\n  username:     'foo@bar.com',\n  password:     'blabla'\n}, function (err, valid) { });\n```\n\n### SSO\n\nMethod `getSSOData` fetches Single Sign-On information:\n\n```js\n  auth0.getSSOData(function (err, ssoData) {\n    if (err) return console.log(err.message);\n    expect(ssoData.sso).to.exist;\n  });\n```\n\nThe returned `ssoData` object will contain the following fields, for example:\n\n```js\n{\n  sso: true,\n  sessionClients: [\n    \"jGMow0KO3WDJELW8XIxolqb1XIitjkYL\"\n  ],\n  lastUsedClientID: \"jGMow0KO3WDJELW8XIxolqb1XIitjkYL\",\n  lastUsedUsername: \"alice@example.com\",\n  lastUsedConnection: {\n    name: \"Username-Password-Authentication\",\n    strategy: \"auth0\"\n  }\n}\n```\n\nLoad Active Directory data if available (Kerberos):\n\n```js\n  auth0.getSSOData(true, fn);\n```\n\nWhen Kerberos is available you can automatically trigger Windows Authentication. As a result the user will immediately be authenticated without taking any action.\n\n```js\n  auth0.getSSOData(true, function (err, ssoData) {\n    if (!err && ssoData && ssoData.connection) {\n      auth0.login({ connection: ssoData.connection });\n    }\n  });\n```\n\n## Develop\n\nRun `grunt dev` and point your browser to `http://localhost:9999/test_harness.html` to run the test suite.\n\nRun `grunt phantom` if you have PhantomJS installed.\n\nRun `grunt integration` (or `npm test`) if you have SauceLabs account. You will need a `SAUCE_ACCESS_KEY` and `SAUCE_USERNAME` env variables.\n\n## Publishing a new version\n\nUse:\n\n```\n$ ./bin/version patch\n$ git push origin master\n```\n\n## Issue Reporting\n\nIf you have found a bug or if you have a feature request, please report them at this repository issues section. Please do not report security vulnerabilities on the public GitHub issue tracker. The [Responsible Disclosure Program](https://auth0.com/whitehat) details the procedure for disclosing security issues.\n\n## Author\n\n[Auth0](auth0.com)\n\n## License\n\nThis project is licensed under the MIT license. See the [LICENSE](LICENSE.txt) file for more info.\n\n<!-- Vaaaaarrrrsss -->\n\n[npm-image]: https://img.shields.io/npm/v/auth0-js.svg?style=flat-square\n[npm-url]: https://npmjs.org/package/auth0-js\n[strider-image]: https://ci.auth0.com/auth0/auth0.js/badge\n[strider-url]: https://ci.auth0.com/auth0/auth0.js\n[coveralls-image]: https://img.shields.io/coveralls/auth0/auth0.js.svg?style=flat-square\n[coveralls-url]: https://coveralls.io/r/auth0/auth0.js?branch=master\n[david-image]: http://img.shields.io/david/auth0/auth0.js.svg?style=flat-square\n[david-url]: https://david-dm.org/auth0/auth0.js\n[license-image]: http://img.shields.io/npm/l/auth0-js.svg?style=flat-square\n[license-url]: #license\n[downloads-image]: http://img.shields.io/npm/dm/auth0-js.svg?style=flat-square\n[downloads-url]: https://npmjs.org/package/auth0-js\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/auth0/auth0.js/issues"
  },
  "_id": "auth0-js@6.8.0",
  "dist": {
    "shasum": "2d28d9367f5d8c23c280e6f28c4b1ea39f6756bc"
  },
  "_from": "auth0-js@",
  "_resolved": "https://registry.npmjs.org/auth0-js/-/auth0-js-6.8.0.tgz"
}
